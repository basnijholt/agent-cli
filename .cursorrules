# Agent CLI - Cursor Rules

This is an AI-powered command-line toolkit for text correction, audio transcription, and voice assistance built with Python 3.11+.

## Development Rules & Practices

### Package Management
- **Always use UV with --all-extras** for installations: `uv pip install -e ".[dev]" --all-extras`
- Use UV for all package management operations
- Maintain clean virtual environments

### Code Quality & Style
- **Prefer functional programming** over class-based inheritance
- Use functions and pure functions when possible
- Avoid complex class hierarchies - favor composition over inheritance
- Use dataclasses or Pydantic models for data structures
- **Keep it DRY** - extract common functionality into utility functions
- Reuse code across modules and create shared utilities

### Testing & Commits
- **Commit frequently** but ensure tests pass before each commit
- Always run `uv run pytest` before committing
- Use descriptive commit messages following conventional commits
- **Always run pre-commit hooks** before committing: `uv run pre-commit run --all-files`

### Pre-commit Setup
- Pre-commit is configured with Ruff (linting & formatting), MyPy (type checking), and basic file checks
- All code must pass these checks before being committed

## Project Architecture

### Core Components
- `agent_cli/` - Main package containing all CLI agents
- `agent_cli/agents/` - Individual agent implementations (autocorrect, transcribe, speak, etc.)
- `agent_cli/audio.py` - Audio device management using PyAudio
- `agent_cli/asr.py` - Automatic Speech Recognition via Wyoming protocol
- `agent_cli/tts.py` - Text-to-Speech functionality
- `agent_cli/llm.py` - LLM integration using Pydantic AI
- `agent_cli/config.py` - Configuration management
- `agent_cli/utils.py` - Shared utilities

### Key Technologies
- **Pydantic AI** for LLM interactions (prefer pydantic-ai-slim)
- **Typer** for CLI interfaces
- **Rich** for terminal UI
- **PyAudio** for audio handling
- **Wyoming** protocol for ASR
- **Ruff** for linting and formatting
- **MyPy** for type checking
- **Pytest** for testing with asyncio support

## Code Patterns & Examples

### ✅ Preferred Patterns

#### Functional Approach
```python
from dataclasses import dataclass
from typing import List, Optional

@dataclass
class ProcessingResult:
    success: bool
    data: Optional[str] = None
    error: Optional[str] = None

def process_text(text: str) -> ProcessingResult:
    """Process text functionally."""
    if not text.strip():
        return ProcessingResult(success=False, error="Empty text")

    processed = text.strip().lower()
    return ProcessingResult(success=True, data=processed)
```

#### Async Functions with Proper Error Handling
```python
async def async_process(data: str) -> ProcessingResult:
    """Async processing with error handling."""
    try:
        result = await some_async_operation(data)
        return ProcessingResult(success=True, data=result)
    except Exception as e:
        return ProcessingResult(success=False, error=str(e))
```

#### CLI Commands with Typer
```python
import typer
from rich.console import Console

def command_handler(
    text: str = typer.Argument(..., help="Text to process"),
    verbose: bool = typer.Option(False, "--verbose", "-v", help="Verbose output"),
) -> None:
    """Command handler following project patterns."""
    console = Console()

    if verbose:
        console.print(f"Processing: {text}")

    result = process_text(text)
    if result.success:
        console.print(result.data)
    else:
        console.print(f"Error: {result.error}", style="red")
```

### ❌ Avoid These Patterns

#### Complex Inheritance
```python
# Don't do this
class BaseProcessor:
    def process(self): pass

class TextProcessor(BaseProcessor):
    def process(self): pass
```

#### Stateful Classes Without Clear Purpose
```python
# Avoid unless necessary
class StatefulProcessor:
    def __init__(self):
        self.state = {}

    def update_state(self, key, value):
        self.state[key] = value
```

## File Organization

### New Files
- Place agent implementations in `agent_cli/agents/`
- Add tests in `tests/` with matching structure
- Use descriptive filenames that match functionality
- Add type annotations and docstrings

### Imports
- Use absolute imports: `from agent_cli.utils import function_name`
- Group imports: stdlib, third-party, local
- Use `from typing import` for type hints

## Testing Guidelines

### Test Structure
- Use pytest with async support
- Create fixtures for common setup
- Test both success and failure cases
- Use descriptive test names: `test_process_text_with_empty_input`

### Mock External Dependencies
- Mock LLM calls in tests
- Mock audio device operations
- Use pytest-asyncio for async tests

## Configuration

### Environment Variables
- Support configuration via environment variables
- Use TOML files for complex configuration
- Provide sensible defaults

### CLI Options
- Use consistent option names across commands
- Provide help text for all options
- Support both short and long option forms

## Development Workflow

1. **Setup**: `python dev.py setup`
2. **During development**: Write functional code, add tests
3. **Before committing**:
   - `python dev.py check` (runs lint + tests)
   - Or manually: `uv run pre-commit run --all-files && uv run pytest`
4. **Commit**: Use descriptive messages

## Error Handling

- Use Result-like patterns with dataclasses
- Provide meaningful error messages
- Log errors appropriately using Rich console
- Handle async exceptions properly

## Performance Considerations

- Use async/await for I/O operations
- Minimize audio buffer operations
- Cache expensive operations when appropriate
- Consider memory usage with large audio files

## Documentation

- Add docstrings to all public functions
- Use type hints consistently
- Update README.md when adding new features
- Document configuration options

Remember: The goal is maintainable, testable, and user-friendly CLI tools. Prioritize clarity and reliability over cleverness.
