"""Configuration management commands for agent-cli."""

from __future__ import annotations

import os
import platform
import shlex
import shutil
import subprocess
from importlib import resources
from pathlib import Path  # noqa: TC003

import typer

from agent_cli.cli import app
from agent_cli.config import CONFIG_PATHS, USER_CONFIG_PATH, _config_path
from agent_cli.core.utils import console

config_app = typer.Typer(
    name="config",
    help="Manage agent-cli configuration files.",
    rich_markup_mode="markdown",
    invoke_without_command=True,
)
app.add_typer(config_app, name="config", rich_help_panel="Configuration")


@config_app.callback()
def config_callback(ctx: typer.Context) -> None:
    """Manage agent-cli configuration files."""
    if ctx.invoked_subcommand is None:
        console.print(ctx.get_help())


# --- Config command options ---
CONFIG_PATH_OPTION: Path | None = typer.Option(
    None,
    "--path",
    "-p",
    help="Path to config file. Uses auto-detection if not specified.",
)
CONFIG_PATH_INIT_OPTION: Path | None = typer.Option(
    None,
    "--path",
    "-p",
    help="Custom path for config file. Default: ~/.config/agent-cli/config.toml",
)
FORCE_OPTION: bool = typer.Option(
    False,  # noqa: FBT003
    "--force",
    "-f",
    help="Overwrite existing config without confirmation.",
)
RAW_OPTION: bool = typer.Option(
    False,  # noqa: FBT003
    "--raw",
    "-r",
    help="Output raw file contents (for copy-paste).",
)


# --- Helper functions ---
def _resolve_config_path(path: Path | None, *, check_exists: bool = True) -> Path | None:
    """Resolve config path with consistent existence checking.

    Args:
        path: Explicit path provided by user, or None for auto-detection.
        check_exists: If True, return None when path doesn't exist.

    Returns:
        Resolved path, or None if not found (when check_exists=True).

    """
    if path is not None:
        resolved = path.expanduser().resolve()
        if check_exists and not resolved.exists():
            return None
        return resolved
    return _config_path(None)


def _print_not_found(explicit_path: Path | None = None, *, show_status: bool = False) -> None:
    """Print config not found message with searched locations."""
    console.print("[yellow]No config file found.[/yellow]")
    if explicit_path is not None:
        console.print(f"\nProvided path does not exist: [cyan]{explicit_path}[/cyan]")
    else:
        console.print("\nSearched locations:")
        for p in CONFIG_PATHS:
            if show_status:
                status = "[green]exists[/green]" if p.exists() else "[dim]not found[/dim]"
                console.print(f"  - {p} ({status})")
            else:
                console.print(f"  - {p}")
    console.print("\nRun [bold cyan]agent-cli config init[/bold cyan] to create one.")


def _get_editor() -> str:
    """Get the user's preferred editor.

    Checks $EDITOR, then $VISUAL, then falls back to platform defaults.
    """
    for env_var in ("EDITOR", "VISUAL"):
        editor = os.environ.get(env_var)
        if editor:
            return editor

    if platform.system() == "Windows":
        return "notepad"

    # Try common editors on Unix-like systems
    for editor in ("nano", "vim", "vi"):
        if shutil.which(editor):
            return editor

    return "vi"


def _generate_template() -> str:
    """Generate a config template with all options commented out."""
    header = """\
# agent-cli configuration file
# Generated by: agent-cli config init
#
# Uncomment and modify options as needed.
# Keys use dashes to match command-line arguments.
# Any option here can be overridden by a command-line argument.
#
# For full documentation, see: https://github.com/basnijholt/agent-cli
"""

    # Example config is bundled with the package
    try:
        template_file = resources.files(__package__) / "example-config.toml"
        example_content = template_file.read_text()
    except FileNotFoundError as e:
        console.print("[red]Example config template is missing from the package.[/red]")
        console.print("Reinstall agent-cli or report this issue.")
        raise typer.Exit(1) from e

    lines = [header.rstrip()]
    skip_header = True  # Skip the original file's header comments

    for line in example_content.splitlines():
        stripped = line.strip()

        # Skip the original header comments (lines before first section)
        if skip_header:
            if stripped.startswith("["):
                skip_header = False
            else:
                continue

        # Keep section headers [defaults], [chat], etc.
        if (
            (stripped.startswith("[") and stripped.endswith("]"))
            or stripped.startswith("#")
            or not stripped
        ):
            lines.append(line)
        # Comment out actual config values
        else:
            lines.append(f"# {line}")

    return "\n".join(lines) + "\n"


@config_app.command("init")
def config_init(
    path: Path | None = CONFIG_PATH_INIT_OPTION,
    force: bool = FORCE_OPTION,
) -> None:
    """Create a new config file with all options commented out.

    The generated config file serves as a template showing all available
    options. Uncomment and modify the options you want to customize.
    """
    target_path = _resolve_config_path(path, check_exists=False) or USER_CONFIG_PATH

    if target_path.exists() and not force:
        console.print(
            f"[bold yellow]Config file already exists at:[/bold yellow] [cyan]{target_path}[/cyan]",
        )
        if not typer.confirm("Overwrite existing config file?"):
            console.print("[dim]Aborted.[/dim]")
            raise typer.Exit(0)

    # Create parent directories
    target_path.parent.mkdir(parents=True, exist_ok=True)

    # Generate and write template
    template_content = _generate_template()
    target_path.write_text(template_content)

    console.print(f"[green]Config file created at:[/green] {target_path}")
    console.print("\n[dim]Edit the file to customize your settings:[/dim]")
    console.print("  [cyan]agent-cli config edit[/cyan]")


@config_app.command("edit")
def config_edit(
    path: Path | None = CONFIG_PATH_OPTION,
) -> None:
    """Open the config file in your default editor.

    The editor is determined by: $EDITOR > $VISUAL > platform default.
    """
    config_file = _resolve_config_path(path)

    if config_file is None:
        _print_not_found(path.expanduser().resolve() if path else None)
        raise typer.Exit(1)

    editor = _get_editor()
    console.print(f"[dim]Opening {config_file} with {editor}...[/dim]")

    try:
        editor_cmd = shlex.split(editor, posix=os.name != "nt")
    except ValueError as e:
        console.print("[red]Invalid editor command. Check $EDITOR/$VISUAL.[/red]")
        raise typer.Exit(1) from e

    if not editor_cmd:
        console.print("[red]Editor command is empty.[/red]")
        raise typer.Exit(1)

    try:
        subprocess.run([*editor_cmd, str(config_file)], check=True)
    except FileNotFoundError:
        console.print(f"[red]Editor '{editor_cmd[0]}' not found.[/red]")
        console.print("Set $EDITOR environment variable to your preferred editor.")
        raise typer.Exit(1) from None
    except subprocess.CalledProcessError as e:
        console.print(f"[red]Editor exited with error code {e.returncode}[/red]")
        raise typer.Exit(e.returncode) from None


@config_app.command("show")
def config_show(
    path: Path | None = CONFIG_PATH_OPTION,
    raw: bool = RAW_OPTION,
) -> None:
    """Display the config file location and contents."""
    config_file = _resolve_config_path(path)

    if config_file is None:
        _print_not_found(
            path.expanduser().resolve() if path else None,
            show_status=path is None,
        )
        raise typer.Exit(1 if path else 0)

    content = config_file.read_text()

    if raw:
        print(content, end="")
        return

    from rich.syntax import Syntax  # noqa: PLC0415

    console.print(f"[bold green]Config file:[/bold green] [cyan]{config_file}[/cyan]")
    console.print()
    syntax = Syntax(content, "toml", theme="monokai", line_numbers=True, word_wrap=True)
    console.print(syntax)
    console.print()
    console.print("[dim]Tip: Use -r for copy-paste friendly output[/dim]")
